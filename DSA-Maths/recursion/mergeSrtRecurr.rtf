{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 /*\
Merge sort using recursion\
*/
\f1\b0 \
import java.util.Arrays;\
public class Main\
\{\
	public static void main(String[] args) \{\
	    int[] arr = \{4,7,3,6,24,5,6,4,6\};\
	    System.out.println(Arrays.toString(mergeSort(arr)));\
	\}\
	\
	static int[] mergeSort(int[] arr) \{\
	    if( arr.length == 1) \{\
	        return arr;\
	    \}\
	    \
	    int mid = arr.length / 2;\
	    int[] leftSideArr = mergeSort(Arrays.copyOfRange(arr, 0, mid));\
	    int[] rightSideArr = mergeSort(Arrays.copyOfRange(arr, mid, arr.length));\
	    \
	    return merge(leftSideArr, rightSideArr);\
	\}\
	\
	static int[] merge(int[] first, int[] second) \{\
	    int[] mix = new int[first.length + second.length];\
	    \
	    int i = 0;\
	    int j = 0;\
	    int k = 0;\
	    \
	    while( i < first.length && j < second.length) \{\
	        if( first[i] <= second[j]) \{\
	            mix[k] = first[i];\
	            i++;\
	        \}else \{\
	            mix[k] = second[j];\
	            j++;\
	        \}\
	        k++;\
	    \}\
	    \
	    while(i < first.length) \{\
	        mix[k] = first[i];\
	        i++;\
	        k++;\
	    \}\
	    \
	    while( j < second.length) \{\
	        mix[k] = second[j];\
	        j++;\
	        k++;\
	    \}\
	    \
	    return mix;\
	\}\
\}\
}