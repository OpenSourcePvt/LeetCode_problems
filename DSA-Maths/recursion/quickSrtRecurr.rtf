{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 /*\
quickSort using recursion\
best case : O(N log N)\
worst: O(square(N))\
This is good over merger sort as it is not required extra space i.e auxiliary space so \
space complexity O(1)\
\
\
\
internal java Arrays.sort(arr)\
this uses quick sort of dualPivot\
time complexity O(N log N) as well as it using heap sort, insertion sort as well as hybrid sorting\
*/
\f1\b0 \
import java.util.Arrays;\
public class Main\
\{\
	public static void main(String[] args) \{\
	    int[] arr = \{4,7,3,6,24,5,6,4,6\};\
	    quickSort(arr, 0, arr.length - 1);\
	    System.out.println(Arrays.toString(arr));\
	\}\
	static void quickSort( int[] arr, int low, int high) \{\
	    if ( low >= high) \{\
	        return;\
	    \}\
	    \
	    int s = low;\
	    int e = high;\
	    int m = s + (e - s) / 2;\
	    int pivot = arr[m];\
	    \
	    while( s <= e) \{\
	        //also a reason why if its already sorted it will not swap\
	        while( arr[s] < pivot) \{\
	            s++;\
	        \}\
	        while(arr[e] > pivot) \{\
	            e--;\
	        \}\
	        \
	        if ( s <= e) \{\
	            int temp = arr[s];\
	            arr[s] = arr[e];\
	            arr[e] = temp;\
	            s++;\
	            e--;\
	        \}\
	    \}\
	    \
	    \
	    //now my pivot is at correct index please sort two halfs now\
	    quickSort(arr, low, e);\
	    quickSort(arr, s, high);\
	\}\
\}\
}